"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const is_valid_identifier_1 = require("../../util/is-valid-identifier");
const find_import_for_identifier_1 = require("../../util/find-import-for-identifier");
const resolve = require('resolve');
const TraceError = require('trace-error');
/**
 * Given a file and ClassDeclaration, finds the name of the superclass and the
 * full path to the module (file) that hosts the superclass.
 *
 * `superclass` and `superclassPath` in the return object will be `null` if
 * there is no superclass.
 */
function parseSuperclassNameAndPath(file, fileClass) {
    let superclassName;
    let superclassPath;
    const heritage = fileClass.getExtends();
    if (heritage) {
        superclassName = heritage.getExpression().getText();
        // Confirm that the superclass is an identifier rather than an
        // expression. It would be a bit much to try to understand expressions
        // as a class's 'extends', so just ignore these for now.
        // Example of ignored class extends:
        //
        //    class MyClass extends Mixin.mix( MixinClass1, MixinClass2 )
        //
        if (!is_valid_identifier_1.isValidIdentifier(superclassName)) {
            superclassName = undefined; // superclass was not a valid identifier
        }
        else if (!!file.getClass(superclassName)) {
            superclassPath = file.getFilePath();
        }
        else {
            superclassPath = findImportPathForIdentifier(file, superclassName);
        }
    }
    return {
        superclassName,
        superclassPath: superclassPath && superclassPath.replace(/\\/g, '/') // normalize backslashes on Windows to forward slashes so we can compare directories with the paths that ts-simple-ast produces
    };
}
exports.parseSuperclassNameAndPath = parseSuperclassNameAndPath;
/**
 * Finds the absolute path for the import with the given `identifier`.
 *
 * For example, if we were looking for the identifier 'MyClass' in the following
 * list of imports:
 *
 *     import { Something } from './somewhere';
 *     import { MyClass } from './my-class';
 *
 * Then the method would return '/absolute/path/to/my-class.js';
 *
 * If there is no import for `identifier`, the method returns `undefined`.
 */
function findImportPathForIdentifier(sourceFile, identifier) {
    const importWithIdentifier = find_import_for_identifier_1.findImportForIdentifier(sourceFile, identifier);
    if (importWithIdentifier) {
        const moduleSpecifier = importWithIdentifier.getModuleSpecifier().getLiteralValue();
        if (!moduleSpecifier.startsWith('.')) {
            // if the import path isn't relative (i.e. doesn't start with './'
            // or '../'), then it must be in node_modules. Return `undefined` to
            // represent that. We don't want to parse node_modules, and we
            // should be able to migrate the codebase without node_modules even
            // being installed.
            return undefined;
        }
        // If it's a relative import, return the absolute path to the module,
        // based on the source file that the import was found
        const basedir = sourceFile.getDirectoryPath();
        try {
            return resolve.sync(moduleSpecifier, {
                basedir,
                extensions: ['.ts', '.js']
            });
        }
        catch (error) {
            throw new TraceError(`
				An error occurred while trying to resolve the absolute path to
				the import of identifier '${identifier}' in source file:
				    '${sourceFile.getFilePath()}'
				    
				Was looking at the import with text:
				    ${importWithIdentifier.getText()}   
			`.trim().replace(/^\t*/gm, ''), error);
        }
    }
    // Nothing found, return undefined
    return undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2Utc3VwZXJjbGFzcy1uYW1lLWFuZC1wYXRoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbnZlcnRlci9hZGQtY2xhc3MtcHJvcGVydHktZGVjbGFyYXRpb25zL3BhcnNlLXN1cGVyY2xhc3MtbmFtZS1hbmQtcGF0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHdFQUFtRTtBQUVuRSxzRkFBZ0Y7QUFDaEYsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFFLFNBQVMsQ0FBRSxDQUFDO0FBQ3JDLE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBRSxhQUFhLENBQUUsQ0FBQztBQUU1Qzs7Ozs7O0dBTUc7QUFDSCxvQ0FDQyxJQUFnQixFQUNoQixTQUEyQjtJQUszQixJQUFJLGNBQWtDLENBQUM7SUFDdkMsSUFBSSxjQUFrQyxDQUFDO0lBRXZDLE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUN4QyxJQUFJLFFBQVEsRUFBRztRQUNkLGNBQWMsR0FBRyxRQUFRLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFcEQsOERBQThEO1FBQzlELHNFQUFzRTtRQUN0RSx3REFBd0Q7UUFDeEQsb0NBQW9DO1FBQ3BDLEVBQUU7UUFDRixpRUFBaUU7UUFDakUsRUFBRTtRQUNGLElBQUksQ0FBQyx1Q0FBaUIsQ0FBRSxjQUFjLENBQUUsRUFBRztZQUMxQyxjQUFjLEdBQUcsU0FBUyxDQUFDLENBQUUsd0NBQXdDO1NBRXJFO2FBQU0sSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBRSxjQUFjLENBQUUsRUFBRztZQUM5QyxjQUFjLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBRXBDO2FBQU07WUFDTixjQUFjLEdBQUcsMkJBQTJCLENBQUUsSUFBSSxFQUFFLGNBQWMsQ0FBRSxDQUFDO1NBQ3JFO0tBQ0Q7SUFFRCxPQUFPO1FBQ04sY0FBYztRQUNkLGNBQWMsRUFBRSxjQUFjLElBQUksY0FBYyxDQUFDLE9BQU8sQ0FBRSxLQUFLLEVBQUUsR0FBRyxDQUFFLENBQUUsK0hBQStIO0tBQ3ZNLENBQUM7QUFDSCxDQUFDO0FBcENELGdFQW9DQztBQUdEOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILHFDQUNDLFVBQXNCLEVBQ3RCLFVBQWtCO0lBRWxCLE1BQU0sb0JBQW9CLEdBQUcsb0RBQXVCLENBQUUsVUFBVSxFQUFFLFVBQVUsQ0FBRSxDQUFDO0lBRS9FLElBQUksb0JBQW9CLEVBQUc7UUFDMUIsTUFBTSxlQUFlLEdBQUcsb0JBQW9CLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUVwRixJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBRSxHQUFHLENBQUUsRUFBRztZQUN4QyxrRUFBa0U7WUFDbEUsb0VBQW9FO1lBQ3BFLDhEQUE4RDtZQUM5RCxtRUFBbUU7WUFDbkUsbUJBQW1CO1lBQ25CLE9BQU8sU0FBUyxDQUFDO1NBQ2pCO1FBRUQscUVBQXFFO1FBQ3JFLHFEQUFxRDtRQUNyRCxNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUM5QyxJQUFJO1lBQ0gsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFFLGVBQWUsRUFBRTtnQkFDckMsT0FBTztnQkFDUCxVQUFVLEVBQUUsQ0FBRSxLQUFLLEVBQUUsS0FBSyxDQUFFO2FBQzVCLENBQUUsQ0FBQztTQUVKO1FBQUMsT0FBTyxLQUFLLEVBQUc7WUFDaEIsTUFBTSxJQUFJLFVBQVUsQ0FBRTs7Z0NBRU8sVUFBVTtXQUMvQixVQUFVLENBQUMsV0FBVyxFQUFFOzs7VUFHekIsb0JBQW9CLENBQUMsT0FBTyxFQUFFO0lBQ3BDLENBQUMsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFFLFFBQVEsRUFBRSxFQUFFLENBQUUsRUFBRSxLQUFLLENBQUUsQ0FBQztTQUMxQztLQUNEO0lBRUQsa0NBQWtDO0lBQ2xDLE9BQU8sU0FBUyxDQUFDO0FBQ2xCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1ZhbGlkSWRlbnRpZmllciB9IGZyb20gXCIuLi8uLi91dGlsL2lzLXZhbGlkLWlkZW50aWZpZXJcIjtcbmltcG9ydCB7IENsYXNzRGVjbGFyYXRpb24sIFNvdXJjZUZpbGUgfSBmcm9tIFwidHMtc2ltcGxlLWFzdFwiO1xuaW1wb3J0IHsgZmluZEltcG9ydEZvcklkZW50aWZpZXIgfSBmcm9tIFwiLi4vLi4vdXRpbC9maW5kLWltcG9ydC1mb3ItaWRlbnRpZmllclwiO1xuY29uc3QgcmVzb2x2ZSA9IHJlcXVpcmUoICdyZXNvbHZlJyApO1xuY29uc3QgVHJhY2VFcnJvciA9IHJlcXVpcmUoICd0cmFjZS1lcnJvcicgKTtcblxuLyoqXG4gKiBHaXZlbiBhIGZpbGUgYW5kIENsYXNzRGVjbGFyYXRpb24sIGZpbmRzIHRoZSBuYW1lIG9mIHRoZSBzdXBlcmNsYXNzIGFuZCB0aGVcbiAqIGZ1bGwgcGF0aCB0byB0aGUgbW9kdWxlIChmaWxlKSB0aGF0IGhvc3RzIHRoZSBzdXBlcmNsYXNzLlxuICpcbiAqIGBzdXBlcmNsYXNzYCBhbmQgYHN1cGVyY2xhc3NQYXRoYCBpbiB0aGUgcmV0dXJuIG9iamVjdCB3aWxsIGJlIGBudWxsYCBpZlxuICogdGhlcmUgaXMgbm8gc3VwZXJjbGFzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3VwZXJjbGFzc05hbWVBbmRQYXRoKFxuXHRmaWxlOiBTb3VyY2VGaWxlLFxuXHRmaWxlQ2xhc3M6IENsYXNzRGVjbGFyYXRpb25cbik6IHtcblx0c3VwZXJjbGFzc05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcblx0c3VwZXJjbGFzc1BhdGg6IHN0cmluZyB8IHVuZGVmaW5lZDtcbn0ge1xuXHRsZXQgc3VwZXJjbGFzc05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcblx0bGV0IHN1cGVyY2xhc3NQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cblx0Y29uc3QgaGVyaXRhZ2UgPSBmaWxlQ2xhc3MuZ2V0RXh0ZW5kcygpO1xuXHRpZiggaGVyaXRhZ2UgKSB7XG5cdFx0c3VwZXJjbGFzc05hbWUgPSBoZXJpdGFnZS5nZXRFeHByZXNzaW9uKCkuZ2V0VGV4dCgpO1xuXG5cdFx0Ly8gQ29uZmlybSB0aGF0IHRoZSBzdXBlcmNsYXNzIGlzIGFuIGlkZW50aWZpZXIgcmF0aGVyIHRoYW4gYW5cblx0XHQvLyBleHByZXNzaW9uLiBJdCB3b3VsZCBiZSBhIGJpdCBtdWNoIHRvIHRyeSB0byB1bmRlcnN0YW5kIGV4cHJlc3Npb25zXG5cdFx0Ly8gYXMgYSBjbGFzcydzICdleHRlbmRzJywgc28ganVzdCBpZ25vcmUgdGhlc2UgZm9yIG5vdy5cblx0XHQvLyBFeGFtcGxlIG9mIGlnbm9yZWQgY2xhc3MgZXh0ZW5kczpcblx0XHQvL1xuXHRcdC8vICAgIGNsYXNzIE15Q2xhc3MgZXh0ZW5kcyBNaXhpbi5taXgoIE1peGluQ2xhc3MxLCBNaXhpbkNsYXNzMiApXG5cdFx0Ly9cblx0XHRpZiggIWlzVmFsaWRJZGVudGlmaWVyKCBzdXBlcmNsYXNzTmFtZSApICkge1xuXHRcdFx0c3VwZXJjbGFzc05hbWUgPSB1bmRlZmluZWQ7ICAvLyBzdXBlcmNsYXNzIHdhcyBub3QgYSB2YWxpZCBpZGVudGlmaWVyXG5cblx0XHR9IGVsc2UgaWYoICEhZmlsZS5nZXRDbGFzcyggc3VwZXJjbGFzc05hbWUgKSApIHtcblx0XHRcdHN1cGVyY2xhc3NQYXRoID0gZmlsZS5nZXRGaWxlUGF0aCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHN1cGVyY2xhc3NQYXRoID0gZmluZEltcG9ydFBhdGhGb3JJZGVudGlmaWVyKCBmaWxlLCBzdXBlcmNsYXNzTmFtZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c3VwZXJjbGFzc05hbWUsXG5cdFx0c3VwZXJjbGFzc1BhdGg6IHN1cGVyY2xhc3NQYXRoICYmIHN1cGVyY2xhc3NQYXRoLnJlcGxhY2UoIC9cXFxcL2csICcvJyApICAvLyBub3JtYWxpemUgYmFja3NsYXNoZXMgb24gV2luZG93cyB0byBmb3J3YXJkIHNsYXNoZXMgc28gd2UgY2FuIGNvbXBhcmUgZGlyZWN0b3JpZXMgd2l0aCB0aGUgcGF0aHMgdGhhdCB0cy1zaW1wbGUtYXN0IHByb2R1Y2VzXG5cdH07XG59XG5cblxuLyoqXG4gKiBGaW5kcyB0aGUgYWJzb2x1dGUgcGF0aCBmb3IgdGhlIGltcG9ydCB3aXRoIHRoZSBnaXZlbiBgaWRlbnRpZmllcmAuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHdlIHdlcmUgbG9va2luZyBmb3IgdGhlIGlkZW50aWZpZXIgJ015Q2xhc3MnIGluIHRoZSBmb2xsb3dpbmdcbiAqIGxpc3Qgb2YgaW1wb3J0czpcbiAqXG4gKiAgICAgaW1wb3J0IHsgU29tZXRoaW5nIH0gZnJvbSAnLi9zb21ld2hlcmUnO1xuICogICAgIGltcG9ydCB7IE15Q2xhc3MgfSBmcm9tICcuL215LWNsYXNzJztcbiAqXG4gKiBUaGVuIHRoZSBtZXRob2Qgd291bGQgcmV0dXJuICcvYWJzb2x1dGUvcGF0aC90by9teS1jbGFzcy5qcyc7XG4gKlxuICogSWYgdGhlcmUgaXMgbm8gaW1wb3J0IGZvciBgaWRlbnRpZmllcmAsIHRoZSBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZmluZEltcG9ydFBhdGhGb3JJZGVudGlmaWVyKFxuXHRzb3VyY2VGaWxlOiBTb3VyY2VGaWxlLFxuXHRpZGVudGlmaWVyOiBzdHJpbmdcbik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG5cdGNvbnN0IGltcG9ydFdpdGhJZGVudGlmaWVyID0gZmluZEltcG9ydEZvcklkZW50aWZpZXIoIHNvdXJjZUZpbGUsIGlkZW50aWZpZXIgKTtcblxuXHRpZiggaW1wb3J0V2l0aElkZW50aWZpZXIgKSB7XG5cdFx0Y29uc3QgbW9kdWxlU3BlY2lmaWVyID0gaW1wb3J0V2l0aElkZW50aWZpZXIuZ2V0TW9kdWxlU3BlY2lmaWVyKCkuZ2V0TGl0ZXJhbFZhbHVlKCk7XG5cblx0XHRpZiggIW1vZHVsZVNwZWNpZmllci5zdGFydHNXaXRoKCAnLicgKSApIHtcblx0XHRcdC8vIGlmIHRoZSBpbXBvcnQgcGF0aCBpc24ndCByZWxhdGl2ZSAoaS5lLiBkb2Vzbid0IHN0YXJ0IHdpdGggJy4vJ1xuXHRcdFx0Ly8gb3IgJy4uLycpLCB0aGVuIGl0IG11c3QgYmUgaW4gbm9kZV9tb2R1bGVzLiBSZXR1cm4gYHVuZGVmaW5lZGAgdG9cblx0XHRcdC8vIHJlcHJlc2VudCB0aGF0LiBXZSBkb24ndCB3YW50IHRvIHBhcnNlIG5vZGVfbW9kdWxlcywgYW5kIHdlXG5cdFx0XHQvLyBzaG91bGQgYmUgYWJsZSB0byBtaWdyYXRlIHRoZSBjb2RlYmFzZSB3aXRob3V0IG5vZGVfbW9kdWxlcyBldmVuXG5cdFx0XHQvLyBiZWluZyBpbnN0YWxsZWQuXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIElmIGl0J3MgYSByZWxhdGl2ZSBpbXBvcnQsIHJldHVybiB0aGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgbW9kdWxlLFxuXHRcdC8vIGJhc2VkIG9uIHRoZSBzb3VyY2UgZmlsZSB0aGF0IHRoZSBpbXBvcnQgd2FzIGZvdW5kXG5cdFx0Y29uc3QgYmFzZWRpciA9IHNvdXJjZUZpbGUuZ2V0RGlyZWN0b3J5UGF0aCgpO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gcmVzb2x2ZS5zeW5jKCBtb2R1bGVTcGVjaWZpZXIsIHtcblx0XHRcdFx0YmFzZWRpcixcblx0XHRcdFx0ZXh0ZW5zaW9uczogWyAnLnRzJywgJy5qcycgXVxuXHRcdFx0fSApO1xuXG5cdFx0fSBjYXRjaCggZXJyb3IgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHJhY2VFcnJvciggYFxuXHRcdFx0XHRBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gcmVzb2x2ZSB0aGUgYWJzb2x1dGUgcGF0aCB0b1xuXHRcdFx0XHR0aGUgaW1wb3J0IG9mIGlkZW50aWZpZXIgJyR7aWRlbnRpZmllcn0nIGluIHNvdXJjZSBmaWxlOlxuXHRcdFx0XHQgICAgJyR7c291cmNlRmlsZS5nZXRGaWxlUGF0aCgpfSdcblx0XHRcdFx0ICAgIFxuXHRcdFx0XHRXYXMgbG9va2luZyBhdCB0aGUgaW1wb3J0IHdpdGggdGV4dDpcblx0XHRcdFx0ICAgICR7aW1wb3J0V2l0aElkZW50aWZpZXIuZ2V0VGV4dCgpfSAgIFxuXHRcdFx0YC50cmltKCkucmVwbGFjZSggL15cXHQqL2dtLCAnJyApLCBlcnJvciApO1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vdGhpbmcgZm91bmQsIHJldHVybiB1bmRlZmluZWRcblx0cmV0dXJuIHVuZGVmaW5lZDtcbn0iXX0=