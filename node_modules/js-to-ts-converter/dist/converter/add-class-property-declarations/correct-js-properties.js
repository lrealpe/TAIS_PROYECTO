"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const js_class_1 = require("./js-class");
const graphlib_1 = require("graphlib");
const logger_1 = require("../../logger/logger");
/**
 * After the graph of original {@link JsClass}es and their properties have been
 * created, we need to remove properties from subclasses that are defined in
 * their superclasses.
 *
 * This function takes the original graph of classes with all properties in each
 * class and returns a new list of JsClasses with the properties properly
 * filtered so that subclasses do not define the same properties that are
 * already present in their superclasses.
 *
 * ## Algorithm
 *
 * 1. Build graph of subclasses -> superclasses
 * 2. Take topological sort of graph
 * 3. Starting at the superclasses in the sort, fill in the
 *    propertySets for each JsClass. For every subclass encountered,
 *    filter out its superclass properties to create the subclass's property
 *    set
 * 4. Use the propertySets to create a new list of JsClasses
 */
function correctJsProperties(jsClasses) {
    logger_1.default.debug('Building graph of class hierarchy to determine which class properties belong to superclasses/subclasses');
    const jsClassHierarchyGraph = new graphlib_1.Graph();
    // First, add all nodes to the graph
    jsClasses.forEach(jsClass => {
        jsClassHierarchyGraph.setNode(jsClass.id, jsClass);
    });
    // Second, connect the subclasses to superclasses in the graph
    jsClasses.forEach(jsClass => {
        if (jsClass.superclassId) {
            // If we come across a JsClass whose superclass is in the node_modules
            // directory (i.e. imported from another package), do not try to
            // go into that package. We're not going to try to understand an ES5
            // module
            if (jsClass.isSuperclassInNodeModules()) {
                return;
            }
            // As a bit of error checking, make sure that we're not going to
            // accidentally create a graph node by adding an edge to
            // jsClass.superclassId. This would happen if we didn't figure out
            // the correct path to the superclass in the parse phase, or we
            // didn't have the superclass's source file added to the project.
            if (!jsClassHierarchyGraph.hasNode(jsClass.superclassId)) {
                throw new Error(`
					An error occurred while adding property declarations to class
					'${jsClass.name}' in file:
					    '${jsClass.path}'
					
					Did not parse this class's superclass ('${jsClass.superclassName}') from file:
					    '${jsClass.superclassPath}'
					during the parse phase. 
					
					Make sure that this class's superclass's .js file is within the 
					directory passed to this conversion utility, or otherwise 
					there is a bug in this utility. Please report at:
					    https://github.com/gregjacobs/js-to-ts-converter/issues
					 
					Debugging info:
					
					This class's graph ID: ${jsClass.id}
					It's superclass's graph ID: ${jsClass.superclassId}
					
					Current IDs in the graph:
					    ${jsClassHierarchyGraph.nodes().join('\n    ')}
				`.replace(/^\t*/gm, ''));
            }
            jsClassHierarchyGraph.setEdge(jsClass.id, jsClass.superclassId);
        }
    });
    // the topological sort is going to put superclasses later in the returned
    // array, so reverse it
    logger_1.default.debug('Topologically sorting the graph in superclass->subclass order');
    const superclassToSubclassOrder = graphlib_1.alg.topsort(jsClassHierarchyGraph).reverse();
    // Starting from superclass JsClass instances and walking down to subclass
    // JsClass instances, fill in the property sets. When a subclass is
    // encountered, take all of the properties that were used in that subclass,
    // minus the properties in its superclass, in order to determine the
    // subclass-specific properties
    superclassToSubclassOrder.forEach(jsClassId => {
        const jsClass = jsClassHierarchyGraph.node(jsClassId);
        const subclassOnlyProperties = new Set(jsClass.properties);
        const superclasses = getSuperclasses(jsClass);
        superclasses.forEach((superclass) => {
            // Filter out both properties and methods from each superclass
            superclass.members.forEach((superclassProp) => {
                subclassOnlyProperties.delete(superclassProp);
            });
        });
        const newJsClass = new js_class_1.JsClass({
            path: jsClass.path,
            name: jsClass.name,
            superclassName: jsClass.superclassName,
            superclassPath: jsClass.superclassPath,
            methods: jsClass.methods,
            properties: subclassOnlyProperties
        });
        // Re-assign the new JsClass with the correct subclass properties back
        // to the graph for the next iteration, in case there is a subclass of
        // the current class which needs to read those properties
        jsClassHierarchyGraph.setNode(jsClassId, newJsClass);
    });
    // Return all of the new JsClass instances with properties corrected for
    // superclass/subclasses
    return jsClassHierarchyGraph.nodes()
        .map(jsClassId => jsClassHierarchyGraph.node(jsClassId));
    function getSuperclasses(jsClass) {
        const superclasses = [];
        while (jsClass.superclassId) {
            const superclass = jsClassHierarchyGraph.node(jsClass.superclassId);
            superclasses.push(superclass);
            jsClass = superclass;
        }
        return superclasses;
    }
}
exports.correctJsProperties = correctJsProperties;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29ycmVjdC1qcy1wcm9wZXJ0aWVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbnZlcnRlci9hZGQtY2xhc3MtcHJvcGVydHktZGVjbGFyYXRpb25zL2NvcnJlY3QtanMtcHJvcGVydGllcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlDQUFxQztBQUNyQyx1Q0FBc0M7QUFDdEMsZ0RBQXlDO0FBRXpDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUJHO0FBQ0gsNkJBQXFDLFNBQW9CO0lBQ3hELGdCQUFNLENBQUMsS0FBSyxDQUFFLHlHQUF5RyxDQUFFLENBQUM7SUFFMUgsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLGdCQUFLLEVBQUUsQ0FBQztJQUUxQyxvQ0FBb0M7SUFDcEMsU0FBUyxDQUFDLE9BQU8sQ0FBRSxPQUFPLENBQUMsRUFBRTtRQUM1QixxQkFBcUIsQ0FBQyxPQUFPLENBQUUsT0FBTyxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUUsQ0FBQztJQUN0RCxDQUFDLENBQUUsQ0FBQztJQUVKLDhEQUE4RDtJQUM5RCxTQUFTLENBQUMsT0FBTyxDQUFFLE9BQU8sQ0FBQyxFQUFFO1FBQzVCLElBQUksT0FBTyxDQUFDLFlBQVksRUFBRztZQUMxQixzRUFBc0U7WUFDdEUsZ0VBQWdFO1lBQ2hFLG9FQUFvRTtZQUNwRSxTQUFTO1lBQ1QsSUFBSSxPQUFPLENBQUMseUJBQXlCLEVBQUUsRUFBRztnQkFDekMsT0FBTzthQUNQO1lBRUQsZ0VBQWdFO1lBQ2hFLHdEQUF3RDtZQUN4RCxrRUFBa0U7WUFDbEUsK0RBQStEO1lBQy9ELGlFQUFpRTtZQUNqRSxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFFLE9BQU8sQ0FBQyxZQUFZLENBQUUsRUFBRztnQkFDNUQsTUFBTSxJQUFJLEtBQUssQ0FBRTs7UUFFYixPQUFPLENBQUMsSUFBSTtZQUNSLE9BQU8sQ0FBQyxJQUFJOzsrQ0FFdUIsT0FBTyxDQUFDLGNBQWM7WUFDekQsT0FBTyxDQUFDLGNBQWM7Ozs7Ozs7Ozs7OEJBVUosT0FBTyxDQUFDLEVBQUU7bUNBQ0wsT0FBTyxDQUFDLFlBQVk7OztXQUc1QyxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUUsUUFBUSxDQUFFO0tBQ3BELENBQUMsT0FBTyxDQUFFLFFBQVEsRUFBRSxFQUFFLENBQUUsQ0FBRSxDQUFDO2FBQzVCO1lBRUQscUJBQXFCLENBQUMsT0FBTyxDQUFFLE9BQU8sQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLFlBQVksQ0FBRSxDQUFDO1NBQ2xFO0lBQ0YsQ0FBQyxDQUFFLENBQUM7SUFFSiwwRUFBMEU7SUFDMUUsdUJBQXVCO0lBQ3ZCLGdCQUFNLENBQUMsS0FBSyxDQUFFLCtEQUErRCxDQUFFLENBQUM7SUFDaEYsTUFBTSx5QkFBeUIsR0FBRyxjQUFHLENBQUMsT0FBTyxDQUFFLHFCQUFxQixDQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7SUFFakYsMEVBQTBFO0lBQzFFLG1FQUFtRTtJQUNuRSwyRUFBMkU7SUFDM0Usb0VBQW9FO0lBQ3BFLCtCQUErQjtJQUMvQix5QkFBeUIsQ0FBQyxPQUFPLENBQUUsU0FBUyxDQUFDLEVBQUU7UUFDOUMsTUFBTSxPQUFPLEdBQUcscUJBQXFCLENBQUMsSUFBSSxDQUFFLFNBQVMsQ0FBYSxDQUFDO1FBQ25FLE1BQU0sc0JBQXNCLEdBQUcsSUFBSSxHQUFHLENBQVUsT0FBTyxDQUFDLFVBQVUsQ0FBRSxDQUFDO1FBRXJFLE1BQU0sWUFBWSxHQUFHLGVBQWUsQ0FBRSxPQUFPLENBQUUsQ0FBQztRQUNoRCxZQUFZLENBQUMsT0FBTyxDQUFFLENBQUUsVUFBbUIsRUFBRyxFQUFFO1lBQy9DLDhEQUE4RDtZQUM5RCxVQUFVLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBRSxDQUFFLGNBQXNCLEVBQUcsRUFBRTtnQkFDeEQsc0JBQXNCLENBQUMsTUFBTSxDQUFFLGNBQWMsQ0FBRSxDQUFDO1lBQ2pELENBQUMsQ0FBRSxDQUFDO1FBQ0wsQ0FBQyxDQUFFLENBQUM7UUFFSixNQUFNLFVBQVUsR0FBRyxJQUFJLGtCQUFPLENBQUU7WUFDL0IsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJO1lBQ2xCLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSTtZQUNsQixjQUFjLEVBQUUsT0FBTyxDQUFDLGNBQWM7WUFDdEMsY0FBYyxFQUFFLE9BQU8sQ0FBQyxjQUFjO1lBQ3RDLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTztZQUN4QixVQUFVLEVBQUUsc0JBQXNCO1NBQ2xDLENBQUUsQ0FBQztRQUVKLHNFQUFzRTtRQUN0RSxzRUFBc0U7UUFDdEUseURBQXlEO1FBQ3pELHFCQUFxQixDQUFDLE9BQU8sQ0FBRSxTQUFTLEVBQUUsVUFBVSxDQUFFLENBQUM7SUFDeEQsQ0FBQyxDQUFFLENBQUM7SUFHSix3RUFBd0U7SUFDeEUsd0JBQXdCO0lBQ3hCLE9BQU8scUJBQXFCLENBQUMsS0FBSyxFQUFFO1NBQ2xDLEdBQUcsQ0FBRSxTQUFTLENBQUMsRUFBRSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBRSxTQUFTLENBQWEsQ0FBRSxDQUFDO0lBR3pFLHlCQUEwQixPQUFnQjtRQUN6QyxNQUFNLFlBQVksR0FBYyxFQUFFLENBQUM7UUFFbkMsT0FBTyxPQUFPLENBQUMsWUFBWSxFQUFHO1lBQzdCLE1BQU0sVUFBVSxHQUFHLHFCQUFxQixDQUFDLElBQUksQ0FBRSxPQUFPLENBQUMsWUFBWSxDQUFhLENBQUM7WUFDakYsWUFBWSxDQUFDLElBQUksQ0FBRSxVQUFVLENBQUUsQ0FBQztZQUVoQyxPQUFPLEdBQUcsVUFBVSxDQUFDO1NBQ3JCO1FBQ0QsT0FBTyxZQUFZLENBQUM7SUFDckIsQ0FBQztBQUNGLENBQUM7QUE5R0Qsa0RBOEdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSnNDbGFzcyB9IGZyb20gXCIuL2pzLWNsYXNzXCI7XG5pbXBvcnQgeyBHcmFwaCwgYWxnIH0gZnJvbSBcImdyYXBobGliXCI7XG5pbXBvcnQgbG9nZ2VyIGZyb20gXCIuLi8uLi9sb2dnZXIvbG9nZ2VyXCI7XG5cbi8qKlxuICogQWZ0ZXIgdGhlIGdyYXBoIG9mIG9yaWdpbmFsIHtAbGluayBKc0NsYXNzfWVzIGFuZCB0aGVpciBwcm9wZXJ0aWVzIGhhdmUgYmVlblxuICogY3JlYXRlZCwgd2UgbmVlZCB0byByZW1vdmUgcHJvcGVydGllcyBmcm9tIHN1YmNsYXNzZXMgdGhhdCBhcmUgZGVmaW5lZCBpblxuICogdGhlaXIgc3VwZXJjbGFzc2VzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgdGhlIG9yaWdpbmFsIGdyYXBoIG9mIGNsYXNzZXMgd2l0aCBhbGwgcHJvcGVydGllcyBpbiBlYWNoXG4gKiBjbGFzcyBhbmQgcmV0dXJucyBhIG5ldyBsaXN0IG9mIEpzQ2xhc3NlcyB3aXRoIHRoZSBwcm9wZXJ0aWVzIHByb3Blcmx5XG4gKiBmaWx0ZXJlZCBzbyB0aGF0IHN1YmNsYXNzZXMgZG8gbm90IGRlZmluZSB0aGUgc2FtZSBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiBhbHJlYWR5IHByZXNlbnQgaW4gdGhlaXIgc3VwZXJjbGFzc2VzLlxuICpcbiAqICMjIEFsZ29yaXRobVxuICpcbiAqIDEuIEJ1aWxkIGdyYXBoIG9mIHN1YmNsYXNzZXMgLT4gc3VwZXJjbGFzc2VzXG4gKiAyLiBUYWtlIHRvcG9sb2dpY2FsIHNvcnQgb2YgZ3JhcGhcbiAqIDMuIFN0YXJ0aW5nIGF0IHRoZSBzdXBlcmNsYXNzZXMgaW4gdGhlIHNvcnQsIGZpbGwgaW4gdGhlXG4gKiAgICBwcm9wZXJ0eVNldHMgZm9yIGVhY2ggSnNDbGFzcy4gRm9yIGV2ZXJ5IHN1YmNsYXNzIGVuY291bnRlcmVkLFxuICogICAgZmlsdGVyIG91dCBpdHMgc3VwZXJjbGFzcyBwcm9wZXJ0aWVzIHRvIGNyZWF0ZSB0aGUgc3ViY2xhc3MncyBwcm9wZXJ0eVxuICogICAgc2V0XG4gKiA0LiBVc2UgdGhlIHByb3BlcnR5U2V0cyB0byBjcmVhdGUgYSBuZXcgbGlzdCBvZiBKc0NsYXNzZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcnJlY3RKc1Byb3BlcnRpZXMoIGpzQ2xhc3NlczogSnNDbGFzc1tdICk6IEpzQ2xhc3NbXSB7XG5cdGxvZ2dlci5kZWJ1ZyggJ0J1aWxkaW5nIGdyYXBoIG9mIGNsYXNzIGhpZXJhcmNoeSB0byBkZXRlcm1pbmUgd2hpY2ggY2xhc3MgcHJvcGVydGllcyBiZWxvbmcgdG8gc3VwZXJjbGFzc2VzL3N1YmNsYXNzZXMnICk7XG5cblx0Y29uc3QganNDbGFzc0hpZXJhcmNoeUdyYXBoID0gbmV3IEdyYXBoKCk7XG5cblx0Ly8gRmlyc3QsIGFkZCBhbGwgbm9kZXMgdG8gdGhlIGdyYXBoXG5cdGpzQ2xhc3Nlcy5mb3JFYWNoKCBqc0NsYXNzID0+IHtcblx0XHRqc0NsYXNzSGllcmFyY2h5R3JhcGguc2V0Tm9kZSgganNDbGFzcy5pZCwganNDbGFzcyApO1xuXHR9ICk7XG5cblx0Ly8gU2Vjb25kLCBjb25uZWN0IHRoZSBzdWJjbGFzc2VzIHRvIHN1cGVyY2xhc3NlcyBpbiB0aGUgZ3JhcGhcblx0anNDbGFzc2VzLmZvckVhY2goIGpzQ2xhc3MgPT4ge1xuXHRcdGlmKCBqc0NsYXNzLnN1cGVyY2xhc3NJZCApIHtcblx0XHRcdC8vIElmIHdlIGNvbWUgYWNyb3NzIGEgSnNDbGFzcyB3aG9zZSBzdXBlcmNsYXNzIGlzIGluIHRoZSBub2RlX21vZHVsZXNcblx0XHRcdC8vIGRpcmVjdG9yeSAoaS5lLiBpbXBvcnRlZCBmcm9tIGFub3RoZXIgcGFja2FnZSksIGRvIG5vdCB0cnkgdG9cblx0XHRcdC8vIGdvIGludG8gdGhhdCBwYWNrYWdlLiBXZSdyZSBub3QgZ29pbmcgdG8gdHJ5IHRvIHVuZGVyc3RhbmQgYW4gRVM1XG5cdFx0XHQvLyBtb2R1bGVcblx0XHRcdGlmKCBqc0NsYXNzLmlzU3VwZXJjbGFzc0luTm9kZU1vZHVsZXMoKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcyBhIGJpdCBvZiBlcnJvciBjaGVja2luZywgbWFrZSBzdXJlIHRoYXQgd2UncmUgbm90IGdvaW5nIHRvXG5cdFx0XHQvLyBhY2NpZGVudGFsbHkgY3JlYXRlIGEgZ3JhcGggbm9kZSBieSBhZGRpbmcgYW4gZWRnZSB0b1xuXHRcdFx0Ly8ganNDbGFzcy5zdXBlcmNsYXNzSWQuIFRoaXMgd291bGQgaGFwcGVuIGlmIHdlIGRpZG4ndCBmaWd1cmUgb3V0XG5cdFx0XHQvLyB0aGUgY29ycmVjdCBwYXRoIHRvIHRoZSBzdXBlcmNsYXNzIGluIHRoZSBwYXJzZSBwaGFzZSwgb3Igd2Vcblx0XHRcdC8vIGRpZG4ndCBoYXZlIHRoZSBzdXBlcmNsYXNzJ3Mgc291cmNlIGZpbGUgYWRkZWQgdG8gdGhlIHByb2plY3QuXG5cdFx0XHRpZiggIWpzQ2xhc3NIaWVyYXJjaHlHcmFwaC5oYXNOb2RlKCBqc0NsYXNzLnN1cGVyY2xhc3NJZCApICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBcblx0XHRcdFx0XHRBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBhZGRpbmcgcHJvcGVydHkgZGVjbGFyYXRpb25zIHRvIGNsYXNzXG5cdFx0XHRcdFx0JyR7anNDbGFzcy5uYW1lfScgaW4gZmlsZTpcblx0XHRcdFx0XHQgICAgJyR7anNDbGFzcy5wYXRofSdcblx0XHRcdFx0XHRcblx0XHRcdFx0XHREaWQgbm90IHBhcnNlIHRoaXMgY2xhc3MncyBzdXBlcmNsYXNzICgnJHtqc0NsYXNzLnN1cGVyY2xhc3NOYW1lfScpIGZyb20gZmlsZTpcblx0XHRcdFx0XHQgICAgJyR7anNDbGFzcy5zdXBlcmNsYXNzUGF0aH0nXG5cdFx0XHRcdFx0ZHVyaW5nIHRoZSBwYXJzZSBwaGFzZS4gXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0TWFrZSBzdXJlIHRoYXQgdGhpcyBjbGFzcydzIHN1cGVyY2xhc3MncyAuanMgZmlsZSBpcyB3aXRoaW4gdGhlIFxuXHRcdFx0XHRcdGRpcmVjdG9yeSBwYXNzZWQgdG8gdGhpcyBjb252ZXJzaW9uIHV0aWxpdHksIG9yIG90aGVyd2lzZSBcblx0XHRcdFx0XHR0aGVyZSBpcyBhIGJ1ZyBpbiB0aGlzIHV0aWxpdHkuIFBsZWFzZSByZXBvcnQgYXQ6XG5cdFx0XHRcdFx0ICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVnamFjb2JzL2pzLXRvLXRzLWNvbnZlcnRlci9pc3N1ZXNcblx0XHRcdFx0XHQgXG5cdFx0XHRcdFx0RGVidWdnaW5nIGluZm86XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0VGhpcyBjbGFzcydzIGdyYXBoIElEOiAke2pzQ2xhc3MuaWR9XG5cdFx0XHRcdFx0SXQncyBzdXBlcmNsYXNzJ3MgZ3JhcGggSUQ6ICR7anNDbGFzcy5zdXBlcmNsYXNzSWR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Q3VycmVudCBJRHMgaW4gdGhlIGdyYXBoOlxuXHRcdFx0XHRcdCAgICAke2pzQ2xhc3NIaWVyYXJjaHlHcmFwaC5ub2RlcygpLmpvaW4oICdcXG4gICAgJyApfVxuXHRcdFx0XHRgLnJlcGxhY2UoIC9eXFx0Ki9nbSwgJycgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRqc0NsYXNzSGllcmFyY2h5R3JhcGguc2V0RWRnZSgganNDbGFzcy5pZCwganNDbGFzcy5zdXBlcmNsYXNzSWQgKTtcblx0XHR9XG5cdH0gKTtcblxuXHQvLyB0aGUgdG9wb2xvZ2ljYWwgc29ydCBpcyBnb2luZyB0byBwdXQgc3VwZXJjbGFzc2VzIGxhdGVyIGluIHRoZSByZXR1cm5lZFxuXHQvLyBhcnJheSwgc28gcmV2ZXJzZSBpdFxuXHRsb2dnZXIuZGVidWcoICdUb3BvbG9naWNhbGx5IHNvcnRpbmcgdGhlIGdyYXBoIGluIHN1cGVyY2xhc3MtPnN1YmNsYXNzIG9yZGVyJyApO1xuXHRjb25zdCBzdXBlcmNsYXNzVG9TdWJjbGFzc09yZGVyID0gYWxnLnRvcHNvcnQoIGpzQ2xhc3NIaWVyYXJjaHlHcmFwaCApLnJldmVyc2UoKTtcblxuXHQvLyBTdGFydGluZyBmcm9tIHN1cGVyY2xhc3MgSnNDbGFzcyBpbnN0YW5jZXMgYW5kIHdhbGtpbmcgZG93biB0byBzdWJjbGFzc1xuXHQvLyBKc0NsYXNzIGluc3RhbmNlcywgZmlsbCBpbiB0aGUgcHJvcGVydHkgc2V0cy4gV2hlbiBhIHN1YmNsYXNzIGlzXG5cdC8vIGVuY291bnRlcmVkLCB0YWtlIGFsbCBvZiB0aGUgcHJvcGVydGllcyB0aGF0IHdlcmUgdXNlZCBpbiB0aGF0IHN1YmNsYXNzLFxuXHQvLyBtaW51cyB0aGUgcHJvcGVydGllcyBpbiBpdHMgc3VwZXJjbGFzcywgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHRoZVxuXHQvLyBzdWJjbGFzcy1zcGVjaWZpYyBwcm9wZXJ0aWVzXG5cdHN1cGVyY2xhc3NUb1N1YmNsYXNzT3JkZXIuZm9yRWFjaCgganNDbGFzc0lkID0+IHtcblx0XHRjb25zdCBqc0NsYXNzID0ganNDbGFzc0hpZXJhcmNoeUdyYXBoLm5vZGUoIGpzQ2xhc3NJZCApIGFzIEpzQ2xhc3M7XG5cdFx0Y29uc3Qgc3ViY2xhc3NPbmx5UHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigganNDbGFzcy5wcm9wZXJ0aWVzICk7XG5cblx0XHRjb25zdCBzdXBlcmNsYXNzZXMgPSBnZXRTdXBlcmNsYXNzZXMoIGpzQ2xhc3MgKTtcblx0XHRzdXBlcmNsYXNzZXMuZm9yRWFjaCggKCBzdXBlcmNsYXNzOiBKc0NsYXNzICkgPT4ge1xuXHRcdFx0Ly8gRmlsdGVyIG91dCBib3RoIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZnJvbSBlYWNoIHN1cGVyY2xhc3Ncblx0XHRcdHN1cGVyY2xhc3MubWVtYmVycy5mb3JFYWNoKCAoIHN1cGVyY2xhc3NQcm9wOiBzdHJpbmcgKSA9PiB7XG5cdFx0XHRcdHN1YmNsYXNzT25seVByb3BlcnRpZXMuZGVsZXRlKCBzdXBlcmNsYXNzUHJvcCApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblxuXHRcdGNvbnN0IG5ld0pzQ2xhc3MgPSBuZXcgSnNDbGFzcygge1xuXHRcdFx0cGF0aDoganNDbGFzcy5wYXRoLFxuXHRcdFx0bmFtZToganNDbGFzcy5uYW1lLFxuXHRcdFx0c3VwZXJjbGFzc05hbWU6IGpzQ2xhc3Muc3VwZXJjbGFzc05hbWUsXG5cdFx0XHRzdXBlcmNsYXNzUGF0aDoganNDbGFzcy5zdXBlcmNsYXNzUGF0aCxcblx0XHRcdG1ldGhvZHM6IGpzQ2xhc3MubWV0aG9kcyxcblx0XHRcdHByb3BlcnRpZXM6IHN1YmNsYXNzT25seVByb3BlcnRpZXNcblx0XHR9ICk7XG5cblx0XHQvLyBSZS1hc3NpZ24gdGhlIG5ldyBKc0NsYXNzIHdpdGggdGhlIGNvcnJlY3Qgc3ViY2xhc3MgcHJvcGVydGllcyBiYWNrXG5cdFx0Ly8gdG8gdGhlIGdyYXBoIGZvciB0aGUgbmV4dCBpdGVyYXRpb24sIGluIGNhc2UgdGhlcmUgaXMgYSBzdWJjbGFzcyBvZlxuXHRcdC8vIHRoZSBjdXJyZW50IGNsYXNzIHdoaWNoIG5lZWRzIHRvIHJlYWQgdGhvc2UgcHJvcGVydGllc1xuXHRcdGpzQ2xhc3NIaWVyYXJjaHlHcmFwaC5zZXROb2RlKCBqc0NsYXNzSWQsIG5ld0pzQ2xhc3MgKTtcblx0fSApO1xuXG5cblx0Ly8gUmV0dXJuIGFsbCBvZiB0aGUgbmV3IEpzQ2xhc3MgaW5zdGFuY2VzIHdpdGggcHJvcGVydGllcyBjb3JyZWN0ZWQgZm9yXG5cdC8vIHN1cGVyY2xhc3Mvc3ViY2xhc3Nlc1xuXHRyZXR1cm4ganNDbGFzc0hpZXJhcmNoeUdyYXBoLm5vZGVzKClcblx0XHQubWFwKCBqc0NsYXNzSWQgPT4ganNDbGFzc0hpZXJhcmNoeUdyYXBoLm5vZGUoIGpzQ2xhc3NJZCApIGFzIEpzQ2xhc3MgKTtcblxuXG5cdGZ1bmN0aW9uIGdldFN1cGVyY2xhc3NlcygganNDbGFzczogSnNDbGFzcyApIHtcblx0XHRjb25zdCBzdXBlcmNsYXNzZXM6IEpzQ2xhc3NbXSA9IFtdO1xuXG5cdFx0d2hpbGUoIGpzQ2xhc3Muc3VwZXJjbGFzc0lkICkge1xuXHRcdFx0Y29uc3Qgc3VwZXJjbGFzcyA9IGpzQ2xhc3NIaWVyYXJjaHlHcmFwaC5ub2RlKCBqc0NsYXNzLnN1cGVyY2xhc3NJZCApIGFzIEpzQ2xhc3M7XG5cdFx0XHRzdXBlcmNsYXNzZXMucHVzaCggc3VwZXJjbGFzcyApO1xuXG5cdFx0XHRqc0NsYXNzID0gc3VwZXJjbGFzcztcblx0XHR9XG5cdFx0cmV0dXJuIHN1cGVyY2xhc3Nlcztcblx0fVxufSJdfQ==