"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts_simple_ast_1 = require("ts-simple-ast");
const logger_1 = require("../logger/logger");
/**
 * Adds the question token to function/method/constructor parameters that are
 * deemed to be optional based on the calls to that function/method/constructor
 * in the codebase.
 *
 * For example, if we have:
 *
 *     function myFn( arg1, arg2, arg3 ) {
 *         // ...
 *     }
 *
 *     myFn( 1, 2, 3 );  // all 3 args provided
 *     myFn( 1, 2 );     // <-- a call site only provides two arguments
 *
 * Then the resulting TypeScript function will be:
 *
 *     function myFn( arg1, arg2, arg3? ) {   // <-- arg3 marked as optional
 *         // ...
 *     }
 *
 * Note: Just calling the language service to look up references takes a lot of
 * time. Might have to optimize this somehow in the future.
 */
function addOptionalsToFunctionParams(tsAstProject) {
    logger_1.default.verbose('Beginning routine to mark function parameters as optional when calls exist that supply fewer args than parameters...');
    const sourceFiles = tsAstProject.getSourceFiles();
    logger_1.default.verbose('Parsing function/method/constructor calls from codebase.');
    const constructorMinArgsMap = parseClassConstructorCalls(sourceFiles);
    const functionsMinArgsMap = parseFunctionAndMethodCalls(sourceFiles);
    logger_1.default.verbose('Marking parameters as optional');
    addOptionals(constructorMinArgsMap);
    addOptionals(functionsMinArgsMap);
    return tsAstProject;
}
exports.addOptionalsToFunctionParams = addOptionalsToFunctionParams;
/**
 * Finds the call sites of each ClassDeclaration's constructor in order to
 * determine if any of its parameters should be marked as optional.
 *
 * Returns a Map keyed by ClassDeclaration which contains the minimum number of
 * arguments passed to that class's constructor.
 *
 * Actually marking the parameters as optional is done in a separate phase.
 */
function parseClassConstructorCalls(sourceFiles) {
    logger_1.default.verbose('Finding all calls to class constructors...');
    const constructorMinArgsMap = new Map();
    sourceFiles.forEach((sourceFile) => {
        logger_1.default.verbose(`  Processing classes in source file: ${sourceFile.getFilePath()}`);
        const classes = sourceFile.getDescendantsOfKind(ts_simple_ast_1.SyntaxKind.ClassDeclaration);
        classes.forEach((classDeclaration) => {
            const constructorFns = classDeclaration.getConstructors() || [];
            const constructorFn = constructorFns.length > 0 ? constructorFns[0] : undefined; // only grab the first since we're converting JavaScript
            // If there is no constructor function for this class, then nothing to do
            if (!constructorFn) {
                return;
            }
            logger_1.default.verbose(`    Looking for calls to the constructor of class: '${classDeclaration.getName()}'`);
            const constructorFnParams = constructorFn.getParameters();
            const numParams = constructorFnParams.length;
            const referencedNodes = classDeclaration.findReferencesAsNodes();
            const callsToConstructor = referencedNodes
                .map((node) => node.getFirstAncestorByKind(ts_simple_ast_1.SyntaxKind.NewExpression))
                .filter((node) => !!node);
            logger_1.default.debug(`    Found ${callsToConstructor.length} call(s) to the constructor`);
            const minNumberOfCallArgs = callsToConstructor
                .reduce((minCallArgs, call) => {
                return Math.min(minCallArgs, call.getArguments().length);
            }, numParams);
            if (callsToConstructor.length > 0) {
                logger_1.default.debug(`    Constructor currently expects ${numParams} params. Call(s) to the constructor supply a minimum of ${minNumberOfCallArgs} args.`);
            }
            constructorMinArgsMap.set(constructorFn, minNumberOfCallArgs);
        });
    });
    return constructorMinArgsMap;
}
/**
 * Finds the call sites of each FunctionDeclaration or MethodDeclaration in
 * order to determine if any of its parameters should be marked as optional.
 *
 * Returns a Map keyed by FunctionDeclaration or MethodDeclaration which contains
 * the minimum number of arguments passed to that function/method.
 *
 * Actually marking the parameters as optional is done in a separate phase.
 */
function parseFunctionAndMethodCalls(sourceFiles) {
    logger_1.default.verbose('Finding all calls to functions/methods...');
    const functionsMinArgsMap = new Map();
    sourceFiles.forEach((sourceFile) => {
        logger_1.default.verbose(`  Processing functions/methods in source file: ${sourceFile.getFilePath()}`);
        const fns = getFunctionsAndMethods(sourceFile);
        fns.forEach((fn) => {
            logger_1.default.verbose(`    Looking for calls to the function: '${fn.getName()}'`);
            const fnParams = fn.getParameters();
            const numParams = fnParams.length;
            const referencedNodes = fn.findReferencesAsNodes();
            const callsToFunction = referencedNodes
                .map((node) => node.getFirstAncestorByKind(ts_simple_ast_1.SyntaxKind.CallExpression))
                .filter((node) => !!node);
            logger_1.default.debug(`    Found ${callsToFunction.length} call(s) to the function '${fn.getName()}'`);
            const minNumberOfCallArgs = callsToFunction
                .reduce((minCallArgs, call) => {
                return Math.min(minCallArgs, call.getArguments().length);
            }, numParams);
            if (callsToFunction.length > 0) {
                logger_1.default.debug(`    Function currently expects ${numParams} params. Call(s) to the function/method supply a minimum of ${minNumberOfCallArgs} args.`);
            }
            functionsMinArgsMap.set(fn, minNumberOfCallArgs);
        });
    });
    return functionsMinArgsMap;
}
/**
 * Retrieves all FunctionDeclarations and MethodDeclarations from the given
 * source file.
 */
function getFunctionsAndMethods(sourceFile) {
    return [].concat(sourceFile.getDescendantsOfKind(ts_simple_ast_1.SyntaxKind.FunctionDeclaration), sourceFile.getDescendantsOfKind(ts_simple_ast_1.SyntaxKind.MethodDeclaration));
}
/**
 * Marks parameters of class constructors / methods / functions as optional
 * based on the minimum number of arguments passed in at its call sites.
 *
 * Ex:
 *
 *     class SomeClass {
 *         constructor( arg1, arg2 ) {}
 *     }
 *     new SomeClass( 1 );  // no arg2
 *
 *     function myFn( arg1, arg2 ) {}
 *     myFn();  // no args
 *
 *
 * Output class and function:
 *
 *     class SomeClass {
 *         constructor( arg1, arg2? ) {}  // <-- arg2 marked as optional
 *     }
 *
 *     function myFn( arg1?, arg2? ) {}   // <-- arg1 and arg2 marked as optional
 */
function addOptionals(minArgsMap) {
    const fns = minArgsMap.keys();
    for (const fn of fns) {
        const fnParams = fn.getParameters();
        const numParams = fnParams.length;
        const minNumberOfCallArgs = minArgsMap.get(fn);
        // Mark all parameters greater than the minNumberOfCallArgs as
        // optional (if it's not a rest parameter or already has a default value)
        for (let i = minNumberOfCallArgs; i < numParams; i++) {
            const param = fnParams[i];
            if (!param.isRestParameter() && !param.hasInitializer()) {
                param.setHasQuestionToken(true);
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRkLW9wdGlvbmFscy10by1mdW5jdGlvbi1wYXJhbXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY29udmVydGVyL2FkZC1vcHRpb25hbHMtdG8tZnVuY3Rpb24tcGFyYW1zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsaURBQXVMO0FBQ3ZMLDZDQUFzQztBQUt0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRztBQUNILHNDQUE4QyxZQUFxQjtJQUNsRSxnQkFBTSxDQUFDLE9BQU8sQ0FBRSxzSEFBc0gsQ0FBRSxDQUFDO0lBQ3pJLE1BQU0sV0FBVyxHQUFHLFlBQVksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUVsRCxnQkFBTSxDQUFDLE9BQU8sQ0FBRSwwREFBMEQsQ0FBRSxDQUFDO0lBQzdFLE1BQU0scUJBQXFCLEdBQUcsMEJBQTBCLENBQUUsV0FBVyxDQUFFLENBQUM7SUFDeEUsTUFBTSxtQkFBbUIsR0FBRywyQkFBMkIsQ0FBRSxXQUFXLENBQUUsQ0FBQztJQUV2RSxnQkFBTSxDQUFDLE9BQU8sQ0FBRSxnQ0FBZ0MsQ0FBRSxDQUFDO0lBQ25ELFlBQVksQ0FBRSxxQkFBcUIsQ0FBRSxDQUFDO0lBQ3RDLFlBQVksQ0FBRSxtQkFBbUIsQ0FBRSxDQUFDO0lBRXBDLE9BQU8sWUFBWSxDQUFDO0FBQ3JCLENBQUM7QUFiRCxvRUFhQztBQUdEOzs7Ozs7OztHQVFHO0FBQ0gsb0NBQXFDLFdBQXlCO0lBQzdELGdCQUFNLENBQUMsT0FBTyxDQUFFLDRDQUE0QyxDQUFFLENBQUM7SUFDL0QsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLEdBQUcsRUFBa0MsQ0FBQztJQUV4RSxXQUFXLENBQUMsT0FBTyxDQUFFLENBQUUsVUFBc0IsRUFBRyxFQUFFO1FBQ2pELGdCQUFNLENBQUMsT0FBTyxDQUFFLHdDQUF3QyxVQUFVLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBRSxDQUFDO1FBQ3JGLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FB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dEUsTUFBTSxHQUFHLEdBQUcsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDO0lBRTlCLEtBQUssTUFBTSxFQUFFLElBQUksR0FBRyxFQUFHO1FBQ3RCLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUVwQyxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDO1FBQ2xDLE1BQU0sbUJBQW1CLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBRSxFQUFFLENBQUcsQ0FBQztRQUVsRCw4REFBOEQ7UUFDOUQseUVBQXlFO1FBQ3pFLEtBQUssSUFBSSxDQUFDLEdBQUcsbUJBQW1CLEVBQUUsQ0FBQyxHQUFHLFNBQVMsRUFBRSxDQUFDLEVBQUUsRUFBRztZQUN0RCxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUUsQ0FBQyxDQUFFLENBQUM7WUFFNUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsRUFBRztnQkFDekQsS0FBSyxDQUFDLG1CQUFtQixDQUFFLElBQUksQ0FBRSxDQUFDO2FBQ2xDO1NBQ0Q7S0FDRDtBQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJvamVjdCwgeyBDYWxsRXhwcmVzc2lvbiwgQ2xhc3NEZWNsYXJhdGlvbiwgQ29uc3RydWN0b3JEZWNsYXJhdGlvbiwgRnVuY3Rpb25EZWNsYXJhdGlvbiwgTWV0aG9kRGVjbGFyYXRpb24sIE5ld0V4cHJlc3Npb24sIE5vZGUsIFNvdXJjZUZpbGUsIFN5bnRheEtpbmQgfSBmcm9tIFwidHMtc2ltcGxlLWFzdFwiO1xuaW1wb3J0IGxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyL2xvZ2dlclwiO1xuXG50eXBlIE5hbWVhYmxlRnVuY3Rpb24gPSBGdW5jdGlvbkRlY2xhcmF0aW9uIHwgTWV0aG9kRGVjbGFyYXRpb247XG50eXBlIEZ1bmN0aW9uVHJhbnNmb3JtVGFyZ2V0ID0gTmFtZWFibGVGdW5jdGlvbiB8IENvbnN0cnVjdG9yRGVjbGFyYXRpb247XG5cbi8qKlxuICogQWRkcyB0aGUgcXVlc3Rpb24gdG9rZW4gdG8gZnVuY3Rpb24vbWV0aG9kL2NvbnN0cnVjdG9yIHBhcmFtZXRlcnMgdGhhdCBhcmVcbiAqIGRlZW1lZCB0byBiZSBvcHRpb25hbCBiYXNlZCBvbiB0aGUgY2FsbHMgdG8gdGhhdCBmdW5jdGlvbi9tZXRob2QvY29uc3RydWN0b3JcbiAqIGluIHRoZSBjb2RlYmFzZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgd2UgaGF2ZTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gbXlGbiggYXJnMSwgYXJnMiwgYXJnMyApIHtcbiAqICAgICAgICAgLy8gLi4uXG4gKiAgICAgfVxuICpcbiAqICAgICBteUZuKCAxLCAyLCAzICk7ICAvLyBhbGwgMyBhcmdzIHByb3ZpZGVkXG4gKiAgICAgbXlGbiggMSwgMiApOyAgICAgLy8gPC0tIGEgY2FsbCBzaXRlIG9ubHkgcHJvdmlkZXMgdHdvIGFyZ3VtZW50c1xuICpcbiAqIFRoZW4gdGhlIHJlc3VsdGluZyBUeXBlU2NyaXB0IGZ1bmN0aW9uIHdpbGwgYmU6XG4gKlxuICogICAgIGZ1bmN0aW9uIG15Rm4oIGFyZzEsIGFyZzIsIGFyZzM/ICkgeyAgIC8vIDwtLSBhcmczIG1hcmtlZCBhcyBvcHRpb25hbFxuICogICAgICAgICAvLyAuLi5cbiAqICAgICB9XG4gKlxuICogTm90ZTogSnVzdCBjYWxsaW5nIHRoZSBsYW5ndWFnZSBzZXJ2aWNlIHRvIGxvb2sgdXAgcmVmZXJlbmNlcyB0YWtlcyBhIGxvdCBvZlxuICogdGltZS4gTWlnaHQgaGF2ZSB0byBvcHRpbWl6ZSB0aGlzIHNvbWVob3cgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZE9wdGlvbmFsc1RvRnVuY3Rpb25QYXJhbXMoIHRzQXN0UHJvamVjdDogUHJvamVjdCApOiBQcm9qZWN0IHtcblx0bG9nZ2VyLnZlcmJvc2UoICdCZWdpbm5pbmcgcm91dGluZSB0byBtYXJrIGZ1bmN0aW9uIHBhcmFtZXRlcnMgYXMgb3B0aW9uYWwgd2hlbiBjYWxscyBleGlzdCB0aGF0IHN1cHBseSBmZXdlciBhcmdzIHRoYW4gcGFyYW1ldGVycy4uLicgKTtcblx0Y29uc3Qgc291cmNlRmlsZXMgPSB0c0FzdFByb2plY3QuZ2V0U291cmNlRmlsZXMoKTtcblxuXHRsb2dnZXIudmVyYm9zZSggJ1BhcnNpbmcgZnVuY3Rpb24vbWV0aG9kL2NvbnN0cnVjdG9yIGNhbGxzIGZyb20gY29kZWJhc2UuJyApO1xuXHRjb25zdCBjb25zdHJ1Y3Rvck1pbkFyZ3NNYXAgPSBwYXJzZUNsYXNzQ29uc3RydWN0b3JDYWxscyggc291cmNlRmlsZXMgKTtcblx0Y29uc3QgZnVuY3Rpb25zTWluQXJnc01hcCA9IHBhcnNlRnVuY3Rpb25BbmRNZXRob2RDYWxscyggc291cmNlRmlsZXMgKTtcblxuXHRsb2dnZXIudmVyYm9zZSggJ01hcmtpbmcgcGFyYW1ldGVycyBhcyBvcHRpb25hbCcgKTtcblx0YWRkT3B0aW9uYWxzKCBjb25zdHJ1Y3Rvck1pbkFyZ3NNYXAgKTtcblx0YWRkT3B0aW9uYWxzKCBmdW5jdGlvbnNNaW5BcmdzTWFwICk7XG5cblx0cmV0dXJuIHRzQXN0UHJvamVjdDtcbn1cblxuXG4vKipcbiAqIEZpbmRzIHRoZSBjYWxsIHNpdGVzIG9mIGVhY2ggQ2xhc3NEZWNsYXJhdGlvbidzIGNvbnN0cnVjdG9yIGluIG9yZGVyIHRvXG4gKiBkZXRlcm1pbmUgaWYgYW55IG9mIGl0cyBwYXJhbWV0ZXJzIHNob3VsZCBiZSBtYXJrZWQgYXMgb3B0aW9uYWwuXG4gKlxuICogUmV0dXJucyBhIE1hcCBrZXllZCBieSBDbGFzc0RlY2xhcmF0aW9uIHdoaWNoIGNvbnRhaW5zIHRoZSBtaW5pbXVtIG51bWJlciBvZlxuICogYXJndW1lbnRzIHBhc3NlZCB0byB0aGF0IGNsYXNzJ3MgY29uc3RydWN0b3IuXG4gKlxuICogQWN0dWFsbHkgbWFya2luZyB0aGUgcGFyYW1ldGVycyBhcyBvcHRpb25hbCBpcyBkb25lIGluIGEgc2VwYXJhdGUgcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NDb25zdHJ1Y3RvckNhbGxzKCBzb3VyY2VGaWxlczogU291cmNlRmlsZVtdICk6IE1hcDxDb25zdHJ1Y3RvckRlY2xhcmF0aW9uLCBudW1iZXI+IHtcblx0bG9nZ2VyLnZlcmJvc2UoICdGaW5kaW5nIGFsbCBjYWxscyB0byBjbGFzcyBjb25zdHJ1Y3RvcnMuLi4nICk7XG5cdGNvbnN0IGNvbnN0cnVjdG9yTWluQXJnc01hcCA9IG5ldyBNYXA8Q29uc3RydWN0b3JEZWNsYXJhdGlvbiwgbnVtYmVyPigpO1xuXG5cdHNvdXJjZUZpbGVzLmZvckVhY2goICggc291cmNlRmlsZTogU291cmNlRmlsZSApID0+IHtcblx0XHRsb2dnZXIudmVyYm9zZSggYCAgUHJvY2Vzc2luZyBjbGFzc2VzIGluIHNvdXJjZSBmaWxlOiAke3NvdXJjZUZpbGUuZ2V0RmlsZVBhdGgoKX1gICk7XG5cdFx0Y29uc3QgY2xhc3NlcyA9IHNvdXJjZUZpbGUuZ2V0RGVzY2VuZGFudHNPZktpbmQoIFN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbiApO1xuXG5cdFx0Y2xhc3Nlcy5mb3JFYWNoKCAoIGNsYXNzRGVjbGFyYXRpb246IENsYXNzRGVjbGFyYXRpb24gKSA9PiB7XG5cdFx0XHRjb25zdCBjb25zdHJ1Y3RvckZucyA9IGNsYXNzRGVjbGFyYXRpb24uZ2V0Q29uc3RydWN0b3JzKCkgfHwgW107XG5cdFx0XHRjb25zdCBjb25zdHJ1Y3RvckZuID0gY29uc3RydWN0b3JGbnMubGVuZ3RoID4gMCA/IGNvbnN0cnVjdG9yRm5zWyAwIF0gOiB1bmRlZmluZWQ7ICAvLyBvbmx5IGdyYWIgdGhlIGZpcnN0IHNpbmNlIHdlJ3JlIGNvbnZlcnRpbmcgSmF2YVNjcmlwdFxuXG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBubyBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhpcyBjbGFzcywgdGhlbiBub3RoaW5nIHRvIGRvXG5cdFx0XHRpZiggIWNvbnN0cnVjdG9yRm4gKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bG9nZ2VyLnZlcmJvc2UoIGAgICAgTG9va2luZyBmb3IgY2FsbHMgdG8gdGhlIGNvbnN0cnVjdG9yIG9mIGNsYXNzOiAnJHtjbGFzc0RlY2xhcmF0aW9uLmdldE5hbWUoKX0nYCApO1xuXG5cdFx0XHRjb25zdCBjb25zdHJ1Y3RvckZuUGFyYW1zID0gY29uc3RydWN0b3JGbi5nZXRQYXJhbWV0ZXJzKCk7XG5cdFx0XHRjb25zdCBudW1QYXJhbXMgPSBjb25zdHJ1Y3RvckZuUGFyYW1zLmxlbmd0aDtcblxuXHRcdFx0Y29uc3QgcmVmZXJlbmNlZE5vZGVzID0gY2xhc3NEZWNsYXJhdGlvbi5maW5kUmVmZXJlbmNlc0FzTm9kZXMoKTtcblxuXHRcdFx0Y29uc3QgY2FsbHNUb0NvbnN0cnVjdG9yID0gcmVmZXJlbmNlZE5vZGVzXG5cdFx0XHRcdC5tYXAoICggbm9kZTogTm9kZSApID0+IG5vZGUuZ2V0Rmlyc3RBbmNlc3RvckJ5S2luZCggU3ludGF4S2luZC5OZXdFeHByZXNzaW9uICkgKVxuXHRcdFx0XHQuZmlsdGVyKCAoIG5vZGUgKTogbm9kZSBpcyBOZXdFeHByZXNzaW9uID0+ICEhbm9kZSApO1xuXG5cdFx0XHRsb2dnZXIuZGVidWcoIGAgICAgRm91bmQgJHtjYWxsc1RvQ29uc3RydWN0b3IubGVuZ3RofSBjYWxsKHMpIHRvIHRoZSBjb25zdHJ1Y3RvcmAgKTtcblxuXHRcdFx0Y29uc3QgbWluTnVtYmVyT2ZDYWxsQXJncyA9IGNhbGxzVG9Db25zdHJ1Y3RvclxuXHRcdFx0XHQucmVkdWNlKCAoIG1pbkNhbGxBcmdzOiBudW1iZXIsIGNhbGw6IE5ld0V4cHJlc3Npb24gKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWluKCBtaW5DYWxsQXJncywgY2FsbC5nZXRBcmd1bWVudHMoKS5sZW5ndGggKTtcblx0XHRcdFx0fSwgbnVtUGFyYW1zICk7XG5cblx0XHRcdGlmKCBjYWxsc1RvQ29uc3RydWN0b3IubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCBgICAgIENvbnN0cnVjdG9yIGN1cnJlbnRseSBleHBlY3RzICR7bnVtUGFyYW1zfSBwYXJhbXMuIENhbGwocykgdG8gdGhlIGNvbnN0cnVjdG9yIHN1cHBseSBhIG1pbmltdW0gb2YgJHttaW5OdW1iZXJPZkNhbGxBcmdzfSBhcmdzLmAgKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3RydWN0b3JNaW5BcmdzTWFwLnNldCggY29uc3RydWN0b3JGbiwgbWluTnVtYmVyT2ZDYWxsQXJncyApO1xuXHRcdH0gKTtcblx0fSApO1xuXG5cdHJldHVybiBjb25zdHJ1Y3Rvck1pbkFyZ3NNYXA7XG59XG5cblxuLyoqXG4gKiBGaW5kcyB0aGUgY2FsbCBzaXRlcyBvZiBlYWNoIEZ1bmN0aW9uRGVjbGFyYXRpb24gb3IgTWV0aG9kRGVjbGFyYXRpb24gaW5cbiAqIG9yZGVyIHRvIGRldGVybWluZSBpZiBhbnkgb2YgaXRzIHBhcmFtZXRlcnMgc2hvdWxkIGJlIG1hcmtlZCBhcyBvcHRpb25hbC5cbiAqXG4gKiBSZXR1cm5zIGEgTWFwIGtleWVkIGJ5IEZ1bmN0aW9uRGVjbGFyYXRpb24gb3IgTWV0aG9kRGVjbGFyYXRpb24gd2hpY2ggY29udGFpbnNcbiAqIHRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoYXQgZnVuY3Rpb24vbWV0aG9kLlxuICpcbiAqIEFjdHVhbGx5IG1hcmtpbmcgdGhlIHBhcmFtZXRlcnMgYXMgb3B0aW9uYWwgaXMgZG9uZSBpbiBhIHNlcGFyYXRlIHBoYXNlLlxuICovXG5mdW5jdGlvbiBwYXJzZUZ1bmN0aW9uQW5kTWV0aG9kQ2FsbHMoIHNvdXJjZUZpbGVzOiBTb3VyY2VGaWxlW10gKTogTWFwPE5hbWVhYmxlRnVuY3Rpb24sIG51bWJlcj4ge1xuXHRsb2dnZXIudmVyYm9zZSggJ0ZpbmRpbmcgYWxsIGNhbGxzIHRvIGZ1bmN0aW9ucy9tZXRob2RzLi4uJyApO1xuXHRjb25zdCBmdW5jdGlvbnNNaW5BcmdzTWFwID0gbmV3IE1hcDxOYW1lYWJsZUZ1bmN0aW9uLCBudW1iZXI+KCk7XG5cblx0c291cmNlRmlsZXMuZm9yRWFjaCggKCBzb3VyY2VGaWxlOiBTb3VyY2VGaWxlICkgPT4ge1xuXHRcdGxvZ2dlci52ZXJib3NlKCBgICBQcm9jZXNzaW5nIGZ1bmN0aW9ucy9tZXRob2RzIGluIHNvdXJjZSBmaWxlOiAke3NvdXJjZUZpbGUuZ2V0RmlsZVBhdGgoKX1gICk7XG5cdFx0Y29uc3QgZm5zID0gZ2V0RnVuY3Rpb25zQW5kTWV0aG9kcyggc291cmNlRmlsZSApO1xuXG5cdFx0Zm5zLmZvckVhY2goICggZm46IE5hbWVhYmxlRnVuY3Rpb24gKSA9PiB7XG5cdFx0XHRsb2dnZXIudmVyYm9zZSggYCAgICBMb29raW5nIGZvciBjYWxscyB0byB0aGUgZnVuY3Rpb246ICcke2ZuLmdldE5hbWUoKX0nYCApO1xuXHRcdFx0Y29uc3QgZm5QYXJhbXMgPSBmbi5nZXRQYXJhbWV0ZXJzKCk7XG5cdFx0XHRjb25zdCBudW1QYXJhbXMgPSBmblBhcmFtcy5sZW5ndGg7XG5cblx0XHRcdGNvbnN0IHJlZmVyZW5jZWROb2RlcyA9IGZuLmZpbmRSZWZlcmVuY2VzQXNOb2RlcygpO1xuXG5cdFx0XHRjb25zdCBjYWxsc1RvRnVuY3Rpb24gPSByZWZlcmVuY2VkTm9kZXNcblx0XHRcdFx0Lm1hcCggKCBub2RlOiBOb2RlICkgPT4gbm9kZS5nZXRGaXJzdEFuY2VzdG9yQnlLaW5kKCBTeW50YXhLaW5kLkNhbGxFeHByZXNzaW9uICkgKVxuXHRcdFx0XHQuZmlsdGVyKCAoIG5vZGUgKTogbm9kZSBpcyBDYWxsRXhwcmVzc2lvbiA9PiAhIW5vZGUgKTtcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCBgICAgIEZvdW5kICR7Y2FsbHNUb0Z1bmN0aW9uLmxlbmd0aH0gY2FsbChzKSB0byB0aGUgZnVuY3Rpb24gJyR7Zm4uZ2V0TmFtZSgpfSdgICk7XG5cblx0XHRcdGNvbnN0IG1pbk51bWJlck9mQ2FsbEFyZ3MgPSBjYWxsc1RvRnVuY3Rpb25cblx0XHRcdFx0LnJlZHVjZSggKCBtaW5DYWxsQXJnczogbnVtYmVyLCBjYWxsOiBDYWxsRXhwcmVzc2lvbiApID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5taW4oIG1pbkNhbGxBcmdzLCBjYWxsLmdldEFyZ3VtZW50cygpLmxlbmd0aCApO1xuXHRcdFx0XHR9LCBudW1QYXJhbXMgKTtcblxuXHRcdFx0aWYoIGNhbGxzVG9GdW5jdGlvbi5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRsb2dnZXIuZGVidWcoIGAgICAgRnVuY3Rpb24gY3VycmVudGx5IGV4cGVjdHMgJHtudW1QYXJhbXN9IHBhcmFtcy4gQ2FsbChzKSB0byB0aGUgZnVuY3Rpb24vbWV0aG9kIHN1cHBseSBhIG1pbmltdW0gb2YgJHttaW5OdW1iZXJPZkNhbGxBcmdzfSBhcmdzLmAgKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb25zTWluQXJnc01hcC5zZXQoIGZuLCBtaW5OdW1iZXJPZkNhbGxBcmdzICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uc01pbkFyZ3NNYXA7XG59XG5cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYWxsIEZ1bmN0aW9uRGVjbGFyYXRpb25zIGFuZCBNZXRob2REZWNsYXJhdGlvbnMgZnJvbSB0aGUgZ2l2ZW5cbiAqIHNvdXJjZSBmaWxlLlxuICovXG5mdW5jdGlvbiBnZXRGdW5jdGlvbnNBbmRNZXRob2RzKFxuXHRzb3VyY2VGaWxlOiBTb3VyY2VGaWxlXG4pOiBOYW1lYWJsZUZ1bmN0aW9uW10ge1xuXHRyZXR1cm4gKCBbXSBhcyBOYW1lYWJsZUZ1bmN0aW9uW10gKS5jb25jYXQoXG5cdFx0c291cmNlRmlsZS5nZXREZXNjZW5kYW50c09mS2luZCggU3ludGF4S2luZC5GdW5jdGlvbkRlY2xhcmF0aW9uICksXG5cdFx0c291cmNlRmlsZS5nZXREZXNjZW5kYW50c09mS2luZCggU3ludGF4S2luZC5NZXRob2REZWNsYXJhdGlvbiApXG5cdCk7XG59XG5cblxuXG4vKipcbiAqIE1hcmtzIHBhcmFtZXRlcnMgb2YgY2xhc3MgY29uc3RydWN0b3JzIC8gbWV0aG9kcyAvIGZ1bmN0aW9ucyBhcyBvcHRpb25hbFxuICogYmFzZWQgb24gdGhlIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyBwYXNzZWQgaW4gYXQgaXRzIGNhbGwgc2l0ZXMuXG4gKlxuICogRXg6XG4gKlxuICogICAgIGNsYXNzIFNvbWVDbGFzcyB7XG4gKiAgICAgICAgIGNvbnN0cnVjdG9yKCBhcmcxLCBhcmcyICkge31cbiAqICAgICB9XG4gKiAgICAgbmV3IFNvbWVDbGFzcyggMSApOyAgLy8gbm8gYXJnMlxuICpcbiAqICAgICBmdW5jdGlvbiBteUZuKCBhcmcxLCBhcmcyICkge31cbiAqICAgICBteUZuKCk7ICAvLyBubyBhcmdzXG4gKlxuICpcbiAqIE91dHB1dCBjbGFzcyBhbmQgZnVuY3Rpb246XG4gKlxuICogICAgIGNsYXNzIFNvbWVDbGFzcyB7XG4gKiAgICAgICAgIGNvbnN0cnVjdG9yKCBhcmcxLCBhcmcyPyApIHt9ICAvLyA8LS0gYXJnMiBtYXJrZWQgYXMgb3B0aW9uYWxcbiAqICAgICB9XG4gKlxuICogICAgIGZ1bmN0aW9uIG15Rm4oIGFyZzE/LCBhcmcyPyApIHt9ICAgLy8gPC0tIGFyZzEgYW5kIGFyZzIgbWFya2VkIGFzIG9wdGlvbmFsXG4gKi9cbmZ1bmN0aW9uIGFkZE9wdGlvbmFscyggbWluQXJnc01hcDogTWFwPEZ1bmN0aW9uVHJhbnNmb3JtVGFyZ2V0LCBudW1iZXI+ICkge1xuXHRjb25zdCBmbnMgPSBtaW5BcmdzTWFwLmtleXMoKTtcblxuXHRmb3IoIGNvbnN0IGZuIG9mIGZucyApIHtcblx0XHRjb25zdCBmblBhcmFtcyA9IGZuLmdldFBhcmFtZXRlcnMoKTtcblxuXHRcdGNvbnN0IG51bVBhcmFtcyA9IGZuUGFyYW1zLmxlbmd0aDtcblx0XHRjb25zdCBtaW5OdW1iZXJPZkNhbGxBcmdzID0gbWluQXJnc01hcC5nZXQoIGZuICkhO1xuXG5cdFx0Ly8gTWFyayBhbGwgcGFyYW1ldGVycyBncmVhdGVyIHRoYW4gdGhlIG1pbk51bWJlck9mQ2FsbEFyZ3MgYXNcblx0XHQvLyBvcHRpb25hbCAoaWYgaXQncyBub3QgYSByZXN0IHBhcmFtZXRlciBvciBhbHJlYWR5IGhhcyBhIGRlZmF1bHQgdmFsdWUpXG5cdFx0Zm9yKCBsZXQgaSA9IG1pbk51bWJlck9mQ2FsbEFyZ3M7IGkgPCBudW1QYXJhbXM7IGkrKyApIHtcblx0XHRcdGNvbnN0IHBhcmFtID0gZm5QYXJhbXNbIGkgXTtcblxuXHRcdFx0aWYoICFwYXJhbS5pc1Jlc3RQYXJhbWV0ZXIoKSAmJiAhcGFyYW0uaGFzSW5pdGlhbGl6ZXIoKSApIHtcblx0XHRcdFx0cGFyYW0uc2V0SGFzUXVlc3Rpb25Ub2tlbiggdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSJdfQ==