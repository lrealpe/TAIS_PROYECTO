"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts_simple_ast_1 = require("ts-simple-ast");
/**
 * Determines if the given `node` is a ElementAccessExpression whose object is
 * `obj`.
 *
 * Example, in the following expression:
 *
 *     obj['a']
 *
 * This function will return true if called as:
 *
 *     isElementAccessWithObj( expr, 'obj' );
 */
function isElementAccessWithObj(node, objIdentifier) {
    if (!ts_simple_ast_1.TypeGuards.isElementAccessExpression(node)) {
        return false;
    }
    const expr = node.getExpression();
    if (objIdentifier === 'this') {
        return ts_simple_ast_1.TypeGuards.isThisExpression(expr);
    }
    else if (ts_simple_ast_1.TypeGuards.isIdentifier(expr)) {
        const identifier = expr;
        return identifier.getText() === objIdentifier;
    }
    else {
        return false;
    }
}
exports.isElementAccessWithObj = isElementAccessWithObj;
/**
 * Function intended to be used with Array.prototype.filter() to return any
 * ElementAccessExpression that uses the object `obj`.
 *
 * For example, in this source code:
 *
 *     const obj = { a: 1, b: 2 };
 *     obj['a'] = 3;
 *
 *     const obj2 = { a: 3, b: 4 };
 *     obj2['b'] = 5;
 *
 * We can use the following to find the 'obj2' element access:
 *
 *     const propAccesses = sourceFile
 *         .getDescendantsOfKind( SyntaxKind.ElementAccessExpression );
 *
 *     const obj2PropAccesses = propAccesses
 *         .filter( elementAccessWithObjFilter( 'obj2' ) );
 */
function elementAccessWithObjFilter(objIdentifier) {
    return (node) => {
        return isElementAccessWithObj(node, objIdentifier);
    };
}
exports.elementAccessWithObjFilter = elementAccessWithObjFilter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXMtZWxlbWVudC1hY2Nlc3Mtd2l0aC1vYmouanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbC9pcy1lbGVtZW50LWFjY2Vzcy13aXRoLW9iai50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGlEQUFzRjtBQUV0Rjs7Ozs7Ozs7Ozs7R0FXRztBQUNILGdDQUNDLElBQVUsRUFDVixhQUFxQjtJQUVyQixJQUFJLENBQUMsMEJBQVUsQ0FBQyx5QkFBeUIsQ0FBRSxJQUFJLENBQUUsRUFBRztRQUNuRCxPQUFPLEtBQUssQ0FBQztLQUNiO0lBRUQsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBRWxDLElBQUksYUFBYSxLQUFLLE1BQU0sRUFBRztRQUM5QixPQUFPLDBCQUFVLENBQUMsZ0JBQWdCLENBQUUsSUFBSSxDQUFFLENBQUM7S0FFM0M7U0FBTSxJQUFJLDBCQUFVLENBQUMsWUFBWSxDQUFFLElBQUksQ0FBRSxFQUFHO1FBQzVDLE1BQU0sVUFBVSxHQUFHLElBQWtCLENBQUM7UUFFdEMsT0FBTyxVQUFVLENBQUMsT0FBTyxFQUFFLEtBQUssYUFBYSxDQUFDO0tBRTlDO1NBQU07UUFDTixPQUFPLEtBQUssQ0FBQztLQUNiO0FBQ0YsQ0FBQztBQXJCRCx3REFxQkM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1CRztBQUNILG9DQUE0QyxhQUFxQjtJQUNoRSxPQUFPLENBQUUsSUFBVSxFQUFvQyxFQUFFO1FBQ3hELE9BQU8sc0JBQXNCLENBQUUsSUFBSSxFQUFFLGFBQWEsQ0FBRSxDQUFDO0lBQ3RELENBQUMsQ0FBQztBQUNILENBQUM7QUFKRCxnRUFJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRBY2Nlc3NFeHByZXNzaW9uLCBJZGVudGlmaWVyLCBOb2RlLCBUeXBlR3VhcmRzIH0gZnJvbSBcInRzLXNpbXBsZS1hc3RcIjtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBgbm9kZWAgaXMgYSBFbGVtZW50QWNjZXNzRXhwcmVzc2lvbiB3aG9zZSBvYmplY3QgaXNcbiAqIGBvYmpgLlxuICpcbiAqIEV4YW1wbGUsIGluIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbjpcbiAqXG4gKiAgICAgb2JqWydhJ11cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRydWUgaWYgY2FsbGVkIGFzOlxuICpcbiAqICAgICBpc0VsZW1lbnRBY2Nlc3NXaXRoT2JqKCBleHByLCAnb2JqJyApO1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50QWNjZXNzV2l0aE9iaihcblx0bm9kZTogTm9kZSxcblx0b2JqSWRlbnRpZmllcjogc3RyaW5nXG4pOiBub2RlIGlzIEVsZW1lbnRBY2Nlc3NFeHByZXNzaW9uIHtcblx0aWYoICFUeXBlR3VhcmRzLmlzRWxlbWVudEFjY2Vzc0V4cHJlc3Npb24oIG5vZGUgKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRjb25zdCBleHByID0gbm9kZS5nZXRFeHByZXNzaW9uKCk7XG5cblx0aWYoIG9iaklkZW50aWZpZXIgPT09ICd0aGlzJyApIHtcblx0XHRyZXR1cm4gVHlwZUd1YXJkcy5pc1RoaXNFeHByZXNzaW9uKCBleHByICk7XG5cblx0fSBlbHNlIGlmKCBUeXBlR3VhcmRzLmlzSWRlbnRpZmllciggZXhwciApICkge1xuXHRcdGNvbnN0IGlkZW50aWZpZXIgPSBleHByIGFzIElkZW50aWZpZXI7XG5cblx0XHRyZXR1cm4gaWRlbnRpZmllci5nZXRUZXh0KCkgPT09IG9iaklkZW50aWZpZXI7XG5cblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGggQXJyYXkucHJvdG90eXBlLmZpbHRlcigpIHRvIHJldHVybiBhbnlcbiAqIEVsZW1lbnRBY2Nlc3NFeHByZXNzaW9uIHRoYXQgdXNlcyB0aGUgb2JqZWN0IGBvYmpgLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbiB0aGlzIHNvdXJjZSBjb2RlOlxuICpcbiAqICAgICBjb25zdCBvYmogPSB7IGE6IDEsIGI6IDIgfTtcbiAqICAgICBvYmpbJ2EnXSA9IDM7XG4gKlxuICogICAgIGNvbnN0IG9iajIgPSB7IGE6IDMsIGI6IDQgfTtcbiAqICAgICBvYmoyWydiJ10gPSA1O1xuICpcbiAqIFdlIGNhbiB1c2UgdGhlIGZvbGxvd2luZyB0byBmaW5kIHRoZSAnb2JqMicgZWxlbWVudCBhY2Nlc3M6XG4gKlxuICogICAgIGNvbnN0IHByb3BBY2Nlc3NlcyA9IHNvdXJjZUZpbGVcbiAqICAgICAgICAgLmdldERlc2NlbmRhbnRzT2ZLaW5kKCBTeW50YXhLaW5kLkVsZW1lbnRBY2Nlc3NFeHByZXNzaW9uICk7XG4gKlxuICogICAgIGNvbnN0IG9iajJQcm9wQWNjZXNzZXMgPSBwcm9wQWNjZXNzZXNcbiAqICAgICAgICAgLmZpbHRlciggZWxlbWVudEFjY2Vzc1dpdGhPYmpGaWx0ZXIoICdvYmoyJyApICk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50QWNjZXNzV2l0aE9iakZpbHRlciggb2JqSWRlbnRpZmllcjogc3RyaW5nICkge1xuXHRyZXR1cm4gKCBub2RlOiBOb2RlICk6IG5vZGUgaXMgRWxlbWVudEFjY2Vzc0V4cHJlc3Npb24gPT4ge1xuXHRcdHJldHVybiBpc0VsZW1lbnRBY2Nlc3NXaXRoT2JqKCBub2RlLCBvYmpJZGVudGlmaWVyICk7XG5cdH07XG59Il19